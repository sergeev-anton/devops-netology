# Задача 1

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и 
её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя

Необходимо отфильтровать CRUD операции в MongoDB которые выполняються более 3-х мин. 

---
````bash
db.currentOp().inprog.forEach(
	  function(op) {
	    if(op.secs_running > 180) printjson(op);
	  }
	)
````
---

Прервать операцию можно с помощью метода db.killOp() (Завершает операцию в соответствии с идентификатором операции)

---
````bash
db.killOp()
````
---


- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

---
````bash

В документации есть метод maxTimeMS(). Этот метод  устанавливает ограничение по времени для операции:
когда операция достигает указанного срока, MongoDB прерывает операцию в следующей точке прерывания.
maxTimeMS() может стать решением зависающих запросах и сможет ограничить по времени операцию выполнения.
````
---

# Задача 2
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

- Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная
и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

- сначала рост отношения записанных значений к истекшим:
- Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?

---
````bash
Проблема может заключаться в том, что срок действия ключей реплик не истекает, вместо этого они ожидают, 
истечения срока действия ключей мастеров. Когда на мастере истекает срок действия ключа (или он удаляется из-за LRU),
он синтезирует команду DEL, которая передается на все реплики. В какой-то момент число команд на запись и удаление 
достигает предела, и новые запросы начинают блокироваться. Так же возможной причиной большого количества ключей с 
истёкшим временем может быть прямое указание времени истечения в unix формате (EXPIREAT), а не TTL ключа в секундах.
````
---

# Задача 3
- Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?
Какие пути решения данной проблемы вы можете предложить?

---
````bash
Ошибка вида (InterfaceError) 2013 показывает: Потеряно соединение с сервером MySQL Т.к. по заданию БД поднято для 
использования в гис-системе, то предпологается увеличение объема информации и возможно не хватает времени системе 
отдать эти данные клиентской стороне. увеличилось количество обрабатываемой информации и это можно решить увеличением 
timeoute. Следует попробовать увеличить значение net_read_timeout с 30 секунд по умолчанию до 60 секунд или более, 
достаточного для завершения передачи данных.
````
---

Задача 4
- Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
postmaster invoked oom-killer
- Как вы думаете, что происходит?
- Как бы вы решили данную проблему?


---
````bash
postmaster invoked oom-killer - это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует \
приложением, чтобы сохранить работу ОС. OOM-Killer вызывает функцию oom_kill_task(). Эта функция отправляет процессу 
сигнал завершения. В случае нехватки памяти oom_kill() вызывает эту функцию, чтобы отправить процессу сигнал SIGKILL.
Причина, по которой в dmesg наблюдается postmaster invoked oom-killer - нехватка памяти.
Если в dmesg наблюдается процесс OOM-Killer, нужно либо настроить postgres для использования меньшего количества памяти,
либо добавить больше оперативной памяти, пока ядро не будет удовлетворено.

````
---


# доп. вопрос : 

- Нужно либо настроить postgres для использования меньшего количества памяти - настройте

ответ:   

---
````bash
В дикектории где расположен файл конфигурации, в моем случае root@NETOLOGY:~# cd /etc/postgresql/12/main/postgresql.conf
открыть postgresql.conf и изменить параметры, регулирующие использование ресурсов, с их помощью можно снизить 
затраты памяти :
- shared_buffers
- max_connections
- effective_cache_size 
- work_mem
- maintenance_work_mem




````
---