# Задача 1

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и 
её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя

Необходимо отфильтровать CRUD операции в MongoDB которые выполняються более 3-х мин. 

---
````bash
db.currentOp().inprog.forEach(
	  function(op) {
	    if(op.secs_running > 180) printjson(op);
	  }
	)
````
---

Прервать операцию можно с помощью метода db.killOp() (Завершает операцию в соответствии с идентификатором операции)

---
````bash
db.killOp()
````
---


- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

---
````bash

В документации есть метод maxTimeMS(). Этот метод  устанавливает ограничение по времени для операции:
когда операция достигает указанного срока, MongoDB прерывает операцию в следующей точке прерывания.
maxTimeMS() может стать решением зависающих запросах и сможет ограничить по времени операцию выполнения.
````
---

# Задача 2
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

- Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная
и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

- сначала рост отношения записанных значений к истекшим:
- Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?

---
````bash
Проблема может заключаться в том, что срок действия ключей реплик не истекает, вместо этого они ожидают, 
истечения срока действия ключей мастеров. Когда на мастере истекает срок действия ключа (или он удаляется из-за LRU),
он синтезирует команду DEL, которая передается на все реплики. В какой-то момент число команд на запись и удаление 
достигает предела, и новые запросы начинают блокироваться. Так же возможной причиной большого количества ключей с 
истёкшим временем может быть прямое указание времени истечения в unix формате (EXPIREAT), а не TTL ключа в секундах.
````
---

# Задача 3
- Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?
Какие пути решения данной проблемы вы можете предложить?

---
````bash
Ошибка вида (InterfaceError) 2013 показывает: Потеряно соединение с сервером MySQL Т.к. по заданию БД поднято для 
использования в гис-системе, то предпологается увеличение объема информации и возможно не хватает времени системе 
отдать эти данные клиентской стороне. увеличилось количество обрабатываемой информации и это можно решить увеличением 
timeoute. Следует попробовать увеличить значение net_read_timeout с 30 секунд по умолчанию до 60 секунд или более, 
достаточного для завершения передачи данных.
````
---

Задача 4
- Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
postmaster invoked oom-killer
- Как вы думаете, что происходит?
- Как бы вы решили данную проблему?


---
````bash
postmaster invoked oom-killer - это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует \
приложением, чтобы сохранить работу ОС. OOM-Killer вызывает функцию oom_kill_task(). Эта функция отправляет процессу 
сигнал завершения. В случае нехватки памяти oom_kill() вызывает эту функцию, чтобы отправить процессу сигнал SIGKILL.
Причина, по которой в dmesg наблюдается postmaster invoked oom-killer - нехватка памяти.
Если в dmesg наблюдается процесс OOM-Killer, нужно либо настроить postgres для использования меньшего количества памяти,
либо добавить больше оперативной памяти, пока ядро не будет удовлетворено.

````
---


доп. вопрос : 

Нужно либо настроить postgres для использования меньшего количества памяти - настройте

ответ  

---
````bash

Если в системе мало памяти и освободить ее невозможно, вызывается функция out_of_memory. На этом этапе ей остается 
только одно — завершить один или несколько процессов. OOM-killer должен завершать процесс сразу или можно подождать? 
Очевидно, что, когда вызывается out_of_memory, это связано с ожиданием операции ввода-вывода или подкачкой страницы
 на диск. Поэтому OOM-killer должен сначала выполнить проверки и на их основе решить, что нужно завершить процесс. 
 Если все приведенные ниже проверки дадут положительный результат, OOM завершит процесс.


Выбор процесса

Когда заканчивается память, вызывается функция out_of_memory(). В ней есть функция select_bad_process(), 
которая получает оценку от функции badness(). Под раздачу попадет самый «плохой» процесс. Функция badness()
 выбирает процесс по определенным правилам.


Ядру нужен какой-то минимум памяти для себя.
Нужно освободить много памяти.
Не нужно завершать процессы, которые используют мало памяти.
Нужно завершить минимум процессов.
Сложные алгоритмы, которые повышают шансы на завершение для тех процессов, которые пользователь сам хочет завершить.

Выполнив все эти проверки, OOM изучает оценку (oom_score). OOM назначает oom_score каждому процессу, а потом умножает 
это значение на объем памяти. У процессов с большими значениями больше шансов стать жертвами OOM Killer. Процессы, 
связанные с привилегированным пользователем, имеют более низкую оценку и меньше шансов на принудительное завершение.


postgres=# SELECT pg_backend_pid();
pg_backend_pid 
----------------
    3813
(1 row)

Идентификатор процесса Postgres — 3813, поэтому в другой оболочке можно получить оценку, используя этот 
параметр ядра oom_score:


vagrant@vagrant:~$ sudo cat /proc/3813/oom_score
2

Если вы совсем не хотите, чтобы OOM-Killer завершил процесс, есть еще один параметр ядра: oom_score_adj.
 Добавьте большое отрицательное значение, чтобы снизить шансы на завершение дорогого вам процесса.


sudo echo -100 > /proc/3813/oom_score_adj

Чтобы задать значение oom_score_adj, установите OOMScoreAdjust в блоке сервиса:


[Service]
OOMScoreAdjust=-1000

Или используйте oomprotect в команде rcctl.


rcctl set <i>servicename</i> oomprotect -1000

Принудительное завершение процесса

Когда один или несколько процессов уже выбраны, OOM-Killer вызывает функцию oom_kill_task(). 
Эта функция отправляет процессу сигнал завершения. В случае нехватки памяти oom_kill() вызывает эту функцию,
 чтобы отправить процессу сигнал SIGKILL. В лог ядра записывается сообщение.


Out of Memory: Killed process [pid] [name].
 



следовательно можно остановить некоторое процессы тем самым высвободив память .
````

---